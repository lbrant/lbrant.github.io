[{"title":"Nexus 5X Root后OTA升级Android Nougat的问题","date":"2017-01-12T06:54:39.793Z","path":"2017/01/12/Nexus-5X-Root续/","text":"###0x01.之前在Android 6.0上面将设备Root后（Root教程），手痒又忍不住通过推送的OTA升级到了Android 7.0（Nougat）,结果之前的Root全部失效，已经安装的SuperSu打开也提示没有Root权限，无奈又打算重新Root。 ###0x02.发现进入[开发者模式]-[OEM解锁]，这一项是灰色的，但是在bootloader模式下，device state提示是unlock，怎么解决这个问题呢？答案是通过重新加锁的方式：1). 先下载fastboot，如果一下再请略过：Windows: Download hereMac: Download here!Linux: Download here!如果经常用这个命令，可以拷贝到android-sdk-windows\\platform-tools目录下。 2). 通过命令行 adb reboot bootloader，或者关机状态下，长按[电源+音量-]; 3). 命令行模式执行 fastboot oem lock，根据手机上提示，通过音量键选中YES，然后电源键确定后，就会自动进入初次开机引导模式； 4). 再次打开开发者模式，发现解锁栏已经可以勾选了。 ###0x03.再次Root，用之前的Root教程中的工具，发现已经Root不了：，到官网上重新去看，CF，下载了新版本，然后执行root-windows.bat，还是弹不出来那个unlock的提示界面； ###0x04. 通过fastboot unlock，在bootloader模式下，执行 fastboot oem unlock，根据提示选择YES，完成后系统就又变成unlocked的状态了； ###0x05. 然后下载twrp-3.0.2-2，下载完成后拷贝到跟fastboot相同目录，然后执行 fastboot flash recovery twrp-3.0.2-2-bullhead.img；注意：尽量到官网下载最新版的，我开始用的3.0.2-0的版本，刷完多次后一直都是停留在TWRP的启动页面，后面刷最新版的就可以了。","tags":[]},{"title":"Hello World","date":"2017-01-12T06:45:57.436Z","path":"2017/01/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"Android Studio Settings Repository Plugin SYNC failed problem","date":"2016-09-22T05:49:10.000Z","path":"2016/09/22/Android-Studio-Settings-Repository-Plugin-SYNC-failed-problem/","text":"##Pre.背景 Android Studio Version：2.2; 某种原因导致Android Studio个人数据设置全部被删，样式回归到“出厂模式”，但在使用SYNC同步的时候，无论Overwrite Local或者Overwrite Remote一直失败，提示：Commit on repo without HEAD currently not supported ##1.解决方案Google搜索了很久，后面在https://youtrack.jetbrains.com/issues中找到了答案。 *1).git clone你Github中settings repository； *2).打开C:\\Users\\%USER%.AndroidStudio2.2\\config\\settingsRepository\\repository目录，并将git目录清空（如果有个性化设置，建议先备份，然后如果该目录不为空的话，请清空），然后将上一步中下载的文件拷贝到此目录。 注：我的Android Studio是2.2版本，其他版本请切换到对应目录。 *3).然后重新启动Android Studio发现所有的style,templete等又回来了，SYNC操作也都正常了。 ##2.使用Access Token第一次Push时会弹出对话框让输入用户名和密码，但是密码存储会有安全隐患，暴露后就要修改密码了，我们可以创建一个Token然后授予相应权限，就能当密码使用了，不想使用的时候直接可以删除Token，不用直接给密码。对Android Studio Settings Repository来说给予Read和Write的权限就可以了：注：创建Access Token只会在创建完成的时候出现，这时候一定要复制下来，并保存起来，如果忘记了就要删去重新创建。","tags":[{"name":"Settings Repository Plugin","slug":"Settings-Repository-Plugin","permalink":"https://lbrant.github.io/tags/Settings-Repository-Plugin/"}]},{"title":"Nexus 5X Root 教程","date":"2016-08-17T10:19:51.000Z","path":"2016/08/17/Nexus-5X-Root-教程/","text":"因为需要安装一个WakeLock Detector的应用，需要用到Root权限，就想着把公司的Nexus 5X Root了，以便以后方便使用。Tips：CF-Auto-Root的好处是不用手动刷内核。 0x01. 准备CF-Auto-Root1.下载地址：CF-Auto-Root-bullhead-bullhead-nexus5x.zip;如果是其他手机，请选择autoroot官网找到相应的手机型号，主要针对Samsung和Nexus系列; 2.解压C:\\USERS\\LENOVO\\DOWNLOADS\\CF-AUTO-ROOT-BULLHEAD-BULLHEAD-NEXUS5X│ root-linux.sh│ root-mac.sh│ root-windows.bat│├─image│ CF-Auto-Root-bullhead-bullhead-nexus5x.img│└─tools AdbWinApi.dll AdbWinUsbApi.dll fastboot-linux fastboot-mac fastboot-windows.exe 0x02. 下载Google USB drivers从网上下载PC端连接手机的驱动，然后安装（如果PC上已经安装，请忽略这一步）； 0x03. 手机开启允许OEM Unlock的选项 Settings-&gt;Developer Options -&gt;Allow OEM Unlock; If you cannot find “Developer Options” under “Settings”, first go to the “Settings-&gt;About” screen, find the “Build number” entry, and tap it 7 times. 0x04. 手机重启为Bootloader/Fastmode模式手机关机，然后长按[Power]+[音量-]键几秒钟，手机会以fastmode模式开机； 0x05. 进行Root 手机通过USB线连上设备，双击运行前面解压过文件夹下的root-windows.bat（Mac和Linux平台执行相应命令）; 按任意键继续运行，这时候手机上会弹出需要确认的操作，请根据手机屏幕上的提示进行操作，[音量+-]键进行上下选择，[Power]键进行确认； 接下来手机就会自动进行Root了，成功后会自动重启。0x06. 检查Root是否成功 手机启动后，会发现被安装了一个SuperUser的应用; 安装RootChecker，如果链接无法打开，就用Baidu|Bing搜索一下; 启动RootChecker，如果出现确认授权的对话框，Root就成功了。","tags":[]},{"title":"ConxtMenu高级用法","date":"2015-11-04T05:31:00.000Z","path":"2015/11/04/ConxtMenu高级用法/","text":"##背景我们经常在列表的页面中，点击列表中的行，一般进入详情页面，长按列表中一行，会弹出一个菜单，包含了对某一行的操作（编辑、删除等等），也知道通常的用法： 0x01. 在Activity中注册需要上下文菜单的View： registerForContextMenu(mListView); 0x02. 然后在Activity中继承onCreateContextMenu方法，添加菜单项： 12345678@Overridepublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) &#123; Log.d(LOG_TAG, &quot;onCreateContextMenu&quot;); super.onCreateContextMenu(menu, v, menuInfo); menu.setHeaderTitle(R.string.prompt); menu.add(Menu.NONE, R.id.context_menu_item_delete_record, Menu.NONE, R.string.delete_record);//groupId, itemId, order, title menu.add(Menu.NONE, R.id.context_menu_item_delete_record_with_file, Menu.NONE, R.string.delete_record_with_file);&#125; PS：每次长按出现上下文菜单都会调用这个方法 12345678910/** * Called when a context menu for the &#123;@code view&#125; is about to be shown. * Unlike &#123;@link #onCreateOptionsMenu(Menu)&#125;, this will be called every * time the context menu is about to be shown and should be populated for * the view (or item inside the view for &#123;@link AdapterView&#125; subclasses, * this can be found in the &#123;@code menuInfo&#125;)). * &lt;p&gt; * Use &#123;@link #onContextItemSelected(android.view.MenuItem)&#125; to know when an * item has been selected. * &lt;p&gt; * It is not safe to hold onto the context menu after this method returns. * */public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) &#123;&#125; 0x03. 接下来长按列表中一行的时候，会弹出上下文菜单： 0x04. 点击菜单后，在Activity中继承onContextItemSelected方法进行处理： 12345@Overridepublic boolean onContextItemSelected(MenuItem item) &#123;switch (item.getItemId())&#123; &#125;&#125; 0x05. 获取Item标识（id）我们删除数据库或者一行记录的时候，要知道主键（一般是id）才能进行操作，很多人就想办法，有的是把ListView的每个ItemView添加一个LongClickListener，然后长按的时候记录下Position，然后在进行相应处理。 其实有更优雅的做法，onContextItemSelected(MenuItem item)回调的参数item可以获取item.getMenuInfo()，在ListView和Adapter的模式中，可以强制转换成AdapterContextMenuInfo，拿到targetView（即所长按行的ItemVew，如果我们需要什么参数，直接放到View.setTag中去即可）： 123AdapterContextMenuInfo info = (AdapterContextMenuInfo) item.getMenuInfo(); int index = info.position; View view = info.targetView; 至此，常见的用法就完了，那么遇到其他自定义View呢？ 0x06. 自定义View的ContextMenu实现下面以用到的RecycleView为例，没有了ListView及其Adapter的封装，我们需要自己处理ContextMenu。最重要的是继承View的两个方法：1.上下文菜单Item的附加信息（上面item.getMenuInfo()）；12345678910/** * Views should implement this if they have extra information to associate * with the context menu. The return result is supplied as a parameter to * the &#123;@link OnCreateContextMenuListener#onCreateContextMenu(ContextMenu, View, ContextMenuInfo)&#125; * callback. * * @return Extra information about the item for which the context menu * should be shown. This information will vary across different * subclasses of View. */protected ContextMenuInfo getContextMenuInfo() &#123; return null;&#125; 2.ViewGroup的showContextMenuForChild，每次弹出上下文菜单都会调用此方法，需要在这里更新ContextMenuInfo；1234/** * &#123;@inheritDoc&#125; */public boolean showContextMenuForChild(View originalView) &#123; return mParent != null &amp;&amp; mParent.showContextMenuForChild(originalView);&#125; 0x07. 自定义RecycleView的ContextMenu全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package com.lbrant.phone.view;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.util.AttributeSet;import android.util.Log;import android.view.ContextMenu;import android.view.View;/** * 作者：dell * 时间：2015/11/3 18:34 * 文件：PhoneRecorder * 描述： */public class ContextMenuRecyclerView extends RecyclerView &#123; private static final String LOG_TAG = &quot;ContextMenuRecyclerView&quot;; private RecyclerContextMenuInfo mContextMenuInfo = new RecyclerContextMenuInfo(); public ContextMenuRecyclerView(Context context) &#123; super(context); &#125; public ContextMenuRecyclerView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public ContextMenuRecyclerView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; @Override protected ContextMenu.ContextMenuInfo getContextMenuInfo() &#123; return mContextMenuInfo; &#125; @Override public boolean showContextMenuForChild(View originalView) &#123; Log.d(LOG_TAG, &quot;showContextMenuForChild&quot;); Object tag = originalView.getTag(); if (tag instanceof RecyclerItemMarker) &#123; mContextMenuInfo.mRecycleItemMarker = (RecyclerItemMarker) tag; &#125; return super.showContextMenuForChild(originalView); &#125; public static class RecyclerItemMarker &#123; public final int position; public final Object obj; public RecyclerItemMarker(int position, Object obj) &#123; this.position = position; this.obj = obj; &#125; &#125; public static class RecyclerContextMenuInfo implements ContextMenu.ContextMenuInfo &#123; public RecyclerItemMarker mRecycleItemMarker; &#125;&#125; private class RecordRecycleViewAdapter extends RecyclerView.Adapter&lt;RecordRecycleViewAdapter.RecordViewHolder&gt; &#123; private Cursor mCallRecordCursor; private int mIdIndex; private int mPhoneNumberIndex; private int mCallTimeIndex; private int mDurationIndex; private int mPathIndex; public RecordRecycleViewAdapter(Cursor cursor) &#123; mCallRecordCursor = cursor; updateCursorColumnIndex(); &#125; private void updateCursorColumnIndex() &#123; if (mCallRecordCursor != null) &#123; mIdIndex = mCallRecordCursor.getColumnIndex(BaseDatabaseHelper.RECORDS_COLUMNS._ID); mPhoneNumberIndex = mCallRecordCursor.getColumnIndex(BaseDatabaseHelper.RECORDS_COLUMNS.NUMBER); mCallTimeIndex = mCallRecordCursor.getColumnIndex(BaseDatabaseHelper.RECORDS_COLUMNS.CALL_TIME); mDurationIndex = mCallRecordCursor.getColumnIndex(BaseDatabaseHelper.RECORDS_COLUMNS.DURATION); mPathIndex = mCallRecordCursor.getColumnIndex(BaseDatabaseHelper.RECORDS_COLUMNS.PATH); &#125; &#125; @Override public RecordRecycleViewAdapter.RecordViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View contentView = LayoutInflater.from(parent.getContext()).inflate(R.layout.record_list_item, parent, false); RecordViewHolder viewHolder = new RecordViewHolder(contentView); return viewHolder; &#125; @Override public void onBindViewHolder(RecordRecycleViewAdapter.RecordViewHolder holder, final int position) &#123; holder.itemView.setLongClickable(true); if (mCallRecordCursor != null &amp;&amp; mCallRecordCursor.moveToPosition(position)) &#123; long id = mCallRecordCursor.getLong(mIdIndex); String phoneNumber = mCallRecordCursor.getString(mPhoneNumberIndex); long seconds = mCallRecordCursor.getLong(mDurationIndex); String callTime = mCallRecordCursor.getString(mCallTimeIndex); String path = mCallRecordCursor.getString(mPathIndex); String duration = String.format(&quot;%1$02d:%2$02d:%3$02d&quot;, seconds / 3600, seconds % 3600 / 60, seconds % 60); RecordInfo info = new RecordInfo(); info.setId(id); info.setPhoneNumber(phoneNumber); info.setSecondsDuration(seconds); info.setCallTime(callTime); info.setPath(path); holder.itemView.setTag(new ContextMenuRecyclerView.RecyclerItemMarker(position, info)); holder.mTextViewPhoneNumber.setText(phoneNumber); holder.mTextViewDuration.setText(duration); holder.mTextviewCallTime.setText(callTime); Cursor cursor = queryContactByPhoneNumber(ContactsContract.CommonDataKinds.Phone.NUMBER + &quot; = &apos;&quot; + phoneNumber + &quot;&apos;&quot;); if (cursor != null) &#123; if (cursor.moveToNext()) &#123; long contactId = cursor.getInt(0); Cursor contactCursor = queryContact(ContactsContract.Contacts._ID + &quot;=&quot; + contactId); if (contactCursor != null) &#123; holder.mTextViewName.setText(contactCursor.getString(1)); contactCursor.close(); &#125; &#125; cursor.close(); &#125; &#125; &#125; @Override public void onViewRecycled(RecordViewHolder holder) &#123; super.onViewRecycled(holder); holder.itemView.setOnCreateContextMenuListener(null); &#125; @Override public int getItemCount() &#123; return mCallRecordCursor == null ? 0 : mCallRecordCursor.getCount(); &#125; public void changeCursor(Cursor cursor) &#123; if (cursor != mCallRecordCursor) &#123; if (mCallRecordCursor != null) &#123; mCallRecordCursor.close(); &#125; mCallRecordCursor = cursor; updateCursorColumnIndex(); notifyDataSetChanged(); &#125; &#125; public class RecordViewHolder extends RecyclerView.ViewHolder &#123; private ImageView mImageViewAvatar; private TextView mTextViewPhoneNumber; private TextView mTextViewName; private TextView mTextviewCallTime; private TextView mTextViewDuration; public RecordViewHolder(View itemView) &#123; super(itemView); mImageViewAvatar = (ImageView) itemView.findViewById(R.id.imageViewAvatar); mTextViewName = (TextView) itemView.findViewById(R.id.textViewName); mTextViewPhoneNumber = (TextView) itemView.findViewById(R.id.textViewPhoneNumber); mTextviewCallTime = (TextView) itemView.findViewById(R.id.textViewCallTime); mTextViewDuration = (TextView) itemView.findViewById(R.id.textViewDuration); &#125; &#125; &#125; 有两个地方需要注意：1.onBindViewHolder中给ItemView添加Tag;2.设置ItemView的LongClickable为true，不然不会出现上下文菜单（具体原因见ContextMenu原理分析）；holder.itemView.setLongClickable(true);","tags":[]}]